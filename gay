# dnevnik_scrape.py
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from bs4 import BeautifulSoup

# ---------- Вставьте свои данные ----------
LOGIN = "your_login_or_email"
PASSWORD = "your_password"
# ------------------------------------------

def start_browser(headless=False):
    chrome_options = Options()
    if headless:
        chrome_options.add_argument("--headless=new")
        chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")
    # Установка драйвера
    driver = webdriver.Chrome(ChromeDriverManager().install(), options=chrome_options)
    driver.maximize_window()
    return driver

def login_dnevnik(driver, login, password):
    # Открываем страницу логина (универсально)
    driver.get("https://login.dnevnik.ru/")
    time.sleep(1.0)

    # Попытаемся найти поля логина/пароля. Сайт может менять атрибуты — пробуем несколько вариантов.
    # 1) По имени/идентификатору
    try:
        inp_login = driver.find_element(By.NAME, "login")
    except:
        try:
            inp_login = driver.find_element(By.ID, "login")
        except:
            inp_login = None

    if inp_login is None:
        # Альтернатива: найдём поле ввода типа text на странице
        inputs = driver.find_elements(By.TAG_NAME, "input")
        inp_login = None
        for i in inputs:
            t = i.get_attribute("type") or ""
            if t.lower() in ("text", "email"):
                inp_login = i
                break

    if inp_login is None:
        raise RuntimeError("Не удалось найти поле логина на странице. Возможно сайт изменил разметку.")

    inp_login.clear()
    inp_login.send_keys(login)
    time.sleep(0.3)

    # Аналогично поле пароля
    try:
        inp_pass = driver.find_element(By.NAME, "password")
    except:
        try:
            inp_pass = driver.find_element(By.ID, "password")
        except:
            inp_pass = None

    if inp_pass is None:
        for i in inputs:
            t = i.get_attribute("type") or ""
            if t.lower() == "password":
                inp_pass = i
                break

    if inp_pass is None:
        raise RuntimeError("Не удалось найти поле пароля на странице.")

    inp_pass.clear()
    inp_pass.send_keys(password)
    time.sleep(0.3)

    # Отправляем форму — пробуем нажать Enter
    inp_pass.send_keys(Keys.RETURN)
    # Ждём редиректа/загрузки страницы профиля
    time.sleep(3.5)

    # Проверим, что авторизация прошла: на странице должны появиться элементы личного кабинета
    if "login" in driver.current_url.lower() or "auth" in driver.current_url.lower():
        # возможно, требуется ручное подтверждение, captcha или 2FA
        raise RuntimeError("Вход не выполнен автоматически — возможно требуется 2FA / captcha / дополнительное подтверждение. Проверьте браузерное окно.")

    return True

def get_marks_html(driver):
    # Перейдём на страницу дневника / журналов/оценок. Типичный URL — дневник (может отличаться):
    # Попытаемся открыть основную страницу дневника
    driver.get("https://dnevnik.ru/")
    time.sleep(2.0)

    # Иногда дневник размещает оценки прямо на главной странице после входа; в противном случае
    # можно попробовать перейти в раздел "Дневник" или "Журнал".
    # Попробуем найти ссылку с текстом "Дневник" / "Журнал" / "Оценки"
    try:
        #ищем элементы ссылок
        anchors = driver.find_elements(By.TAG_NAME, "a")
        target = None
        for a in anchors:
            t = a.text.strip().lower()
            if "дневник" in t or "журнал" in t or "оценки" in t:
                target = a
                break
        if target:
            target.click()
            time.sleep(2.0)
        else:
            # если не нашли — оставим текущую страницу
            pass
    except Exception:
        pass

    # Даем JS прогрузиться
    time.sleep(2.0)
    html = driver.page_source
    return html

def parse_marks(html):
    soup = BeautifulSoup(html, "html.parser")

    # Попытаемся найти все предметы и оценки.
    # Подход: найти блоки, содержащие название предмета и рядом стоящие оценки.
    results = {}

    # Вариант 1: искать блоки с классом, содержащим "subject" или "lesson"
    subject_blocks = soup.find_all(lambda tag:
                                   tag.name in ("div", "section") and
                                   (tag.get("class") and any("subject" in cl.lower() or "lesson" in cl.lower() for cl in tag.get("class"))))

    # Если ничего не найдено — попробуем искать заголовки <h3>, <h4> которые выглядят как предметы
    if not subject_blocks:
        headers = soup.find_all(["h3", "h4", "h2"])
        for h in headers:
            text = h.get_text(strip=True)
            if not text:
                continue
            # простая эвристика: если в тексте есть русские буквы и длина < 60 — вероятно это предмет
            if any("а" <= ch <= "я" or "А" <= ch <= "Я" for ch in text) and len(text) < 60:
                # найдем соседние элементы с цифрами (оценками)
                sibling_text = ""
                # смотрим несколько следующих sibling'ов на предмет оценок
                for sib in h.find_next_siblings(limit=6):
                    sibling_text += " " + sib.get_text(separator=" ", strip=True)
                # ищем числа 2-5
                marks = []
                for token in sibling_text.split():
                    if token.isdigit() and token in ("2","3","4","5"):
                        marks.append(token)
                if marks:
                    results[text] = marks

    # Если нашли subject_blocks — анализируем их на предметы и оценки
    for blk in subject_blocks:
        # попытка получить заголовок предмета внутри блока
        title = None
        for tagname in ("h3","h4","h2","b","strong"):
            t = blk.find(tagname)
            if t and t.get_text(strip=True):
                title = t.get_text(strip=True)
                break
        if not title:
            # возможно название в атрибуте
            title = blk.get("data-subject") or blk.get("aria-label") or None
        if not title:
            # если нет — пропускаем
            continue

        # найти оценки в блоке: цифры 2..5 или буквы (З/н/нб и т.п.)
        marks = []
        # ищем элементы, где текст — короткая оценка
        for el in blk.find_all(text=True):
            txt = el.strip()
            if not txt:
                continue
            # фильтруем короткие токены, содержащие цифры оценки
            for token in txt.split():
                if token in ("2","3","4","5"):
                    marks.append(token)
        if marks:
            results[title] = marks

    return results

def main():
    driver = start_browser(headless=False)  # headless=True если не хотите окно
    try:
        login_dnevnik(driver, LOGIN, PASSWORD)
        print("Вход выполнен, получаем страницу дневника...")
        html = get_marks_html(driver)
        parsed = parse_marks(html)

        if not parsed:
            print("Не удалось найти оценки автоматически. Вывожу HTML-кусок для анализа (сокращённый):")
            print(html[:3000])  # покажем начало страницы — можно по нему подстроить парсер
            return

        print("\nНайденные предметы и оценки:")
        for subj, marks in parsed.items():
            print(f"- {subj}: {', '.join(marks)}")

    except Exception as e:
        print("Ошибка:", e)
    finally:
        # Закрываем браузер через 2 секунды, чтобы успели увидеть результат
        time.sleep(2)
        driver.quit()

if __name__ == "__main__":
    main()